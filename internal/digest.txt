Directory structure:
└── internal/
    ├── api/
    │   ├── token_api.go
    │   ├── user_api.go
    │   └── workout_api.go
    ├── database/
    │   └── database.go
    ├── handlers/
    │   ├── dashboard_handler.go
    │   ├── hello_handler.go
    │   ├── login_handler.go
    │   ├── signup_handler.go
    │   └── workout_handlers.go
    ├── middleware/
    │   └── middleware.go
    ├── server/
    │   ├── routes.go
    │   └── server.go
    ├── store/
    │   ├── token_store.go
    │   ├── user_store.go
    │   └── workout_store.go
    ├── tokens/
    │   └── tokens.go
    └── utils/
        └── utils.go

================================================
File: api/token_api.go
================================================
package api

import (
	"encoding/json"
	"log"
	"net/http"
	"time"

	"github.com/strangecousinwst/goworkout/internal/store"
	"github.com/strangecousinwst/goworkout/internal/tokens"
	"github.com/strangecousinwst/goworkout/internal/utils"
)

type TokenAPI struct {
	tokenStore store.TokenStore
	userStore  store.UserStore
	logger     *log.Logger
}

type createTokenRequest struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

func NewTokenAPI(tokenStore store.TokenStore, userStore store.UserStore, logger *log.Logger) *TokenAPI {
	return &TokenAPI{
		tokenStore: tokenStore,
		userStore:  userStore,
		logger:     logger,
	}
}

func (h *TokenAPI) HandleCreateToken(w http.ResponseWriter, r *http.Request) {
	var req createTokenRequest
	err := json.NewDecoder(r.Body).Decode(&req)

	if err != nil {
		h.logger.Printf("ERROR: createTokenRequest: %v", err)
		utils.WriteJSON(w, http.StatusBadRequest, utils.Envelope{"error": "Invalid request payload"})
		return
	}

	// lets get the user
	user, err := h.userStore.GetUserByUsername(req.Username)
	if err != nil || user == nil {
		h.logger.Printf("ERROR: getUserByUsername: %v", err)
		utils.WriteJSON(w, http.StatusInternalServerError, utils.Envelope{"error": "internal server error"})
		return
	}

	passwordsDoMatch, err := user.PasswordHash.Matches(req.Password)
	if err != nil {
		h.logger.Printf("ERROR: PasswordHash.Matches %v", err)
		utils.WriteJSON(w, http.StatusInternalServerError, utils.Envelope{"error": "internal server error"})
		return
	}

	if !passwordsDoMatch {
		utils.WriteJSON(w, http.StatusUnauthorized, utils.Envelope{"error": "invalid credentials"})
		return
	}

	token, err := h.tokenStore.CreateNewToken(user.ID, 24*time.Hour, tokens.ScopeAuth)
	if err != nil {
		h.logger.Printf("ERROR: Creating Token %v", err)
		utils.WriteJSON(w, http.StatusInternalServerError, utils.Envelope{"error": "internal server error"})
		return
	}

	utils.WriteJSON(w, http.StatusCreated, utils.Envelope{"token": token.Hash})
}



================================================
File: api/user_api.go
================================================
package api

import (
	"encoding/json"
	"errors"
	"log"
	"net/http"
	"regexp"

	"github.com/strangecousinwst/goworkout/internal/store"
	"github.com/strangecousinwst/goworkout/internal/utils"
)

type registerUserRequest struct {
	Username string `json:"username"`
	Email    string `json:"email"`
	Password string `json:"password"`
	Bio      string `json:"bio"`
}

type UserAPI struct {
	userStore store.UserStore
	logger    *log.Logger
}

func NewUserAPI(userStore store.UserStore, logger *log.Logger) *UserAPI {
	return &UserAPI{
		userStore: userStore,
		logger:    logger,
	}
}

// TODO: Implement more validation
func (h *UserAPI) ValidateRegisterRequest(req *registerUserRequest) error {
	if req.Username == "" {
		return errors.New("username is required")
	}
	if len(req.Username) < 3 {
		return errors.New("username must be at least 3 characters long")
	} else if len(req.Username) > 20 {
		return errors.New("username must be at most 20 characters long")
	}

	if req.Email == "" {
		return errors.New("email is required")
	}
	if len(req.Email) < 5 {
		return errors.New("email must be at least 5 characters long")
	} else if len(req.Email) > 50 {
		return errors.New("username must be at most 50 characters long")
	}
	emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
	if !emailRegex.MatchString(req.Email) {
		return errors.New("invalid email format")
	}

	if req.Password == "" {
		return errors.New("password is required")
	}

	return nil
}

func (h *UserAPI) HandleRegisterUser(w http.ResponseWriter, r *http.Request) {
	var req registerUserRequest

	err := json.NewDecoder(r.Body).Decode(&req)
	if err != nil {
		h.logger.Printf("ERROR: decoding register request: %v", err)
		utils.WriteJSON(w, http.StatusBadRequest, utils.Envelope{"error": "invalid request payload"})
	}

	err = h.ValidateRegisterRequest(&req)
	if err != nil {
		utils.WriteJSON(w, http.StatusBadRequest, utils.Envelope{"error": err.Error()})
		return
	}

	user := &store.User{
		Username: req.Username,
		Email:    req.Email,
	}

	if req.Bio != "" {
		user.Bio = req.Bio
	}

	err = user.PasswordHash.Set(req.Password)
	if err != nil {
		h.logger.Printf("ERROR: hashing password: %v", err)
		utils.WriteJSON(w, http.StatusInternalServerError, utils.Envelope{"error": "internal server error"})
		return
	}

	err = h.userStore.CreateUser(user)
	if err != nil {
		h.logger.Printf("ERROR: registering user: %v", err)
		utils.WriteJSON(w, http.StatusInternalServerError, utils.Envelope{"error": "internal server error"})
		return
	}

	utils.WriteJSON(w, http.StatusCreated, utils.Envelope{"user": user})
}



================================================
File: api/workout_api.go
================================================
package api

import (
	"database/sql"
	"encoding/json"
	"errors"
	"log"
	"net/http"

	"github.com/strangecousinwst/goworkout/internal/middleware"
	"github.com/strangecousinwst/goworkout/internal/store"
	"github.com/strangecousinwst/goworkout/internal/utils"
)

type WorkoutAPI struct {
	workoutStore store.WorkoutStore
	logger       *log.Logger
}

func NewWorkoutAPI(workoutStore store.WorkoutStore, logger *log.Logger) *WorkoutAPI {
	return &WorkoutAPI{
		workoutStore: workoutStore,
		logger:       logger,
	}
}

func (wh *WorkoutAPI) HandleGetWorkoutByID(w http.ResponseWriter, r *http.Request) {
	workoutID, err := utils.ReadIDParam(r)
	if err != nil {
		wh.logger.Printf("ERROR: readIDParam: %v", err)
		utils.WriteJSON(w, http.StatusBadRequest, utils.Envelope{"error": "invalid workout ID"})
		return
	}

	workout, err := wh.workoutStore.GetWorkoutByID(workoutID)
	if err != nil {
		wh.logger.Printf("ERROR: getWorkoutByID: %v", err)
		utils.WriteJSON(w, http.StatusInternalServerError, utils.Envelope{"error": "invalid server error"})
		return
	}

	utils.WriteJSON(w, http.StatusOK, utils.Envelope{"workout": workout})
}

func (wh *WorkoutAPI) HandleCreateWorkout(w http.ResponseWriter, r *http.Request) {
	var workout store.Workout
	err := json.NewDecoder(r.Body).Decode(&workout)
	if err != nil {
		wh.logger.Printf("ERROR: decodingCreateWorkout: %v", err)
		utils.WriteJSON(w, http.StatusBadRequest, utils.Envelope{"error": "invalid request sent"})
		return
	}

	currentUser := middleware.GetUser(r)
	if currentUser == nil || currentUser == store.AnonymousUser {
		utils.WriteJSON(w, http.StatusBadRequest, utils.Envelope{"error": "you must be logged in"})
	}

	workout.UserID = currentUser.ID

	createdWorkout, err := wh.workoutStore.CreateWorkout(&workout)
	if err != nil {
		wh.logger.Printf("ERROR: creatingWorkout: %v", err)
		utils.WriteJSON(w, http.StatusInternalServerError, utils.Envelope{"error": "failed to create workout"})
		return
	}

	utils.WriteJSON(w, http.StatusCreated, utils.Envelope{"workout": createdWorkout})
}

func (wh *WorkoutAPI) HandleUpdateWorkoutByID(w http.ResponseWriter, r *http.Request) {
	workoutID, err := utils.ReadIDParam(r)
	if err != nil {
		wh.logger.Printf("ERROR: readIDParam: %v", err)
		utils.WriteJSON(w, http.StatusBadRequest, utils.Envelope{"error": "invalid workout update ID"})
		return
	}

	existingWorkout, err := wh.workoutStore.GetWorkoutByID(workoutID)
	if err != nil {
		wh.logger.Printf("ERROR: getWorkoutByID: %v", err)
		utils.WriteJSON(w, http.StatusInternalServerError, utils.Envelope{"error": "internal server error"})
		return
	}

	if existingWorkout == nil {
		http.NotFound(w, r)
		return
	}

	// at this point we can assume we are able to find the workout
	var updateWorkoutRequest struct {
		Title           *string              `json:"title"`
		Description     *string              `json:"description"`
		DurationMinutes *int                 `json:"duration_minutes"`
		CaloriesBurned  *int                 `json:"calories_burned"`
		Entries         []store.WorkoutEntry `json:"entries"`
	}

	err = json.NewDecoder(r.Body).Decode(&updateWorkoutRequest)
	if err != nil {
		wh.logger.Printf("ERROR: decondingUpdateRequest: %v", err)
		utils.WriteJSON(w, http.StatusBadRequest, utils.Envelope{"error": "invalid request payload"})
		return
	}

	if updateWorkoutRequest.Title != nil {
		existingWorkout.Title = *updateWorkoutRequest.Title
	}
	if updateWorkoutRequest.Description != nil {
		existingWorkout.Description = *updateWorkoutRequest.Description
	}
	if updateWorkoutRequest.DurationMinutes != nil {
		existingWorkout.DurationMinutes = *updateWorkoutRequest.DurationMinutes
	}
	if updateWorkoutRequest.CaloriesBurned != nil {
		existingWorkout.CaloriesBurned = *updateWorkoutRequest.CaloriesBurned
	}
	if updateWorkoutRequest.Entries != nil {
		existingWorkout.Entries = updateWorkoutRequest.Entries
	}

	currentUser := middleware.GetUser(r)
	if currentUser == nil || currentUser == store.AnonymousUser {
		utils.WriteJSON(w, http.StatusBadRequest, utils.Envelope{"error": "you must be logged in"})
		return
	}

	workoutOwner, err := wh.workoutStore.GetWorkoutOwner(workoutID)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			utils.WriteJSON(w, http.StatusNotFound, utils.Envelope{"error": "workout does not exist"})
			return
		}

		utils.WriteJSON(w, http.StatusInternalServerError, utils.Envelope{"error": "internal server error"})
		return
	}

	if workoutOwner != currentUser.ID {
		utils.WriteJSON(w, http.StatusForbidden, utils.Envelope{"error": "you do not have permission to update this workout"})
		return
	}

	err = wh.workoutStore.UpdateWorkout(existingWorkout)
	if err != nil {
		wh.logger.Printf("ERROR: updatingWorkout: %v", err)
		utils.WriteJSON(w, http.StatusInternalServerError, utils.Envelope{"error": "internal server error"})
		return
	}

	utils.WriteJSON(w, http.StatusOK, utils.Envelope{"workout": existingWorkout})
}

func (wh *WorkoutAPI) HandleDeleteWorkoutByID(w http.ResponseWriter, r *http.Request) {
	workoutID, err := utils.ReadIDParam(r)
	if err != nil {
		wh.logger.Printf("ERROR: readIDParam: %v", err)
		utils.WriteJSON(w, http.StatusBadRequest, utils.Envelope{"error": "invalid workout delete ID"})
		return
	}

	currentUser := middleware.GetUser(r)
	if currentUser == nil || currentUser == store.AnonymousUser {
		utils.WriteJSON(w, http.StatusBadRequest, utils.Envelope{"error": "you must be logged in"})
		return
	}

	workoutOwner, err := wh.workoutStore.GetWorkoutOwner(workoutID)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			utils.WriteJSON(w, http.StatusNotFound, utils.Envelope{"error": "workout does not exist"})
			return
		}

		utils.WriteJSON(w, http.StatusInternalServerError, utils.Envelope{"error": "internal server error"})
		return
	}

	if workoutOwner != currentUser.ID {
		utils.WriteJSON(w, http.StatusForbidden, utils.Envelope{"error": "you do not have permission to delete this workout"})
		return
	}

	err = wh.workoutStore.DeleteWorkout(workoutID)
	if err == sql.ErrNoRows {
		http.Error(w, "workout not found", http.StatusNotFound)
		return
	}

	if err != nil {
		wh.logger.Printf("ERROR: deletingWorkout: %v", err)
		utils.WriteJSON(w, http.StatusInternalServerError, utils.Envelope{"error": "internal server error"})
		return
	}

	w.WriteHeader(http.StatusNoContent)
}



================================================
File: database/database.go
================================================
package database

import (
	"context"
	"database/sql"
	"fmt"
	"io/fs"
	"log"
	"os"
	"strconv"
	"time"

	_ "github.com/jackc/pgx/v5/stdlib"
	_ "github.com/joho/godotenv/autoload"
	"github.com/pressly/goose/v3"
)

// Service represents a service that interacts with a database.
type Service interface {
	// Health returns a map of health status information.
	// The keys and values in the map are service-specific.
	Health() map[string]string

	// Close terminates the database connection.
	// It returns an error if the connection cannot be closed.
	Close() error

	// Gets a pointer to the database
	GetDB() *sql.DB
}

type service struct {
	db *sql.DB
}

var (
	database   = os.Getenv("GOWORKOUT_DB_DATABASE")
	password   = os.Getenv("GOWORKOUT_DB_PASSWORD")
	username   = os.Getenv("GOWORKOUT_DB_USERNAME")
	port       = os.Getenv("GOWORKOUT_DB_PORT")
	host       = os.Getenv("GOWORKOUT_DB_HOST")
	schema     = os.Getenv("GOWORKOUT_DB_SCHEMA")
	dbInstance *service
)

func New() Service {
	// Reuse Connection
	if dbInstance != nil {
		return dbInstance
	}
	connStr := fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable&search_path=%s", username, password, host, port, database, schema)
	db, err := sql.Open("pgx", connStr)
	if err != nil {
		log.Fatal(err)
	}
	dbInstance = &service{
		db: db,
	}
	return dbInstance
}

func (s *service) GetDB() *sql.DB {
	return s.db
}

func MigrateFS(db *sql.DB, migrationsFS fs.FS, dir string) error {
	goose.SetBaseFS(migrationsFS)
	defer func() {
		goose.SetBaseFS(nil)
	}()

	return Migrate(db, dir)
}

func Migrate(db *sql.DB, dir string) error {
	err := goose.SetDialect("postgres")
	if err != nil {
		return fmt.Errorf("migrate: %w", err)
	}

	err = goose.Up(db, dir)
	if err != nil {
		return fmt.Errorf("goose up: %w", err)
	}

	return nil
}

// Health checks the health of the database connection by pinging the database.
// It returns a map with keys indicating various health statistics.
func (s *service) Health() map[string]string {
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
	defer cancel()

	stats := make(map[string]string)

	// Ping the database
	err := s.db.PingContext(ctx)
	if err != nil {
		stats["status"] = "down"
		stats["error"] = fmt.Sprintf("db down: %v", err)
		log.Fatalf("db down: %v", err) // Log the error and terminate the program
		return stats
	}

	// Database is up, add more statistics
	stats["status"] = "up"
	stats["message"] = "It's healthy"

	// Get database stats (like open connections, in use, idle, etc.)
	dbStats := s.db.Stats()
	stats["open_connections"] = strconv.Itoa(dbStats.OpenConnections)
	stats["in_use"] = strconv.Itoa(dbStats.InUse)
	stats["idle"] = strconv.Itoa(dbStats.Idle)
	stats["wait_count"] = strconv.FormatInt(dbStats.WaitCount, 10)
	stats["wait_duration"] = dbStats.WaitDuration.String()
	stats["max_idle_closed"] = strconv.FormatInt(dbStats.MaxIdleClosed, 10)
	stats["max_lifetime_closed"] = strconv.FormatInt(dbStats.MaxLifetimeClosed, 10)

	// Evaluate stats to provide a health message
	if dbStats.OpenConnections > 40 { // Assuming 50 is the max for this example
		stats["message"] = "The database is experiencing heavy load."
	}

	if dbStats.WaitCount > 1000 {
		stats["message"] = "The database has a high number of wait events, indicating potential bottlenecks."
	}

	if dbStats.MaxIdleClosed > int64(dbStats.OpenConnections)/2 {
		stats["message"] = "Many idle connections are being closed, consider revising the connection pool settings."
	}

	if dbStats.MaxLifetimeClosed > int64(dbStats.OpenConnections)/2 {
		stats["message"] = "Many connections are being closed due to max lifetime, consider increasing max lifetime or revising the connection usage pattern."
	}

	return stats
}

// Close closes the database connection.
// It logs a message indicating the disconnection from the specific database.
// If the connection is successfully closed, it returns nil.
// If an error occurs while closing the connection, it returns the error.
func (s *service) Close() error {
	log.Printf("Disconnected from database: %s", database)
	return s.db.Close()
}



================================================
File: handlers/dashboard_handler.go
================================================
package handlers

import (
	"log"
	"net/http"

	"github.com/strangecousinwst/goworkout/cmd/web"
	"github.com/strangecousinwst/goworkout/internal/middleware"
	"github.com/strangecousinwst/goworkout/internal/store"
)

// DashboardHandler renders the dashboard showing user's workouts
func DashboardHandler(workoutStore store.WorkoutStore) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		user := middleware.GetUser(r)

		var workouts []store.Workout
		var err error

		if user == nil && user == store.AnonymousUser {
			http.Redirect(w, r, "/login", http.StatusSeeOther)
			return
		}

		if user != nil && user != store.AnonymousUser {
			// Get the user's workouts
			workouts, err = workoutStore.GetWorkoutsForUser(user.ID)
			if err != nil {
				log.Printf("Error getting workouts: %v", err)
				http.Error(w, "Error loading workouts", http.StatusInternalServerError)
				return
			}
		}

		err = web.Dashboard(workouts).Render(r.Context(), w)
		if err != nil {
			log.Printf("Error rendering dashboard: %v", err)
		}
	}
}



================================================
File: handlers/hello_handler.go
================================================
package handlers

import (
	"net/http"

	"github.com/strangecousinwst/goworkout/cmd/web"
)

func HelloWebHandler(w http.ResponseWriter, r *http.Request) {
	r.ParseForm()

	name := r.FormValue("name")
	if name == "" {
		name = "World"
	}

	// err = component.Render(r.Context(), w)
	// if err != nil {
	// 	http.Error(w, err.Error(), http.StatusBadRequest)
	// 	log.Fatalf("Error rendering in HelloWebHandler: %e", err)
	// }
	web.HelloPost(name).Render(r.Context(), w)
}



================================================
File: handlers/login_handler.go
================================================
package handlers

import (
	"log"
	"net/http"
	"time"

	"github.com/strangecousinwst/goworkout/cmd/web"
	"github.com/strangecousinwst/goworkout/internal/store"
	"github.com/strangecousinwst/goworkout/internal/tokens"
)

// LoginWebHandler handles both GET and POST requests for /login
func LoginWebHandler(userStore store.UserStore, tokenStore store.TokenStore) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method == http.MethodPost {
			err := r.ParseForm()
			if err != nil {
				http.Error(w, "Bad Request", http.StatusInternalServerError)
				return
			}

			username := r.FormValue("username")
			password := r.FormValue("password")

			if username == "" || password == "" {
				web.LoginForm("Username and password required").Render(r.Context(), w)
				return
			}

			// Authenticate user
			user, err := userStore.GetUserByUsername(username)
			if err != nil || user == nil {
				web.LoginForm("Invalid username or password").Render(r.Context(), w)
				return
			}

			// Check password
			match, err := user.PasswordHash.Matches(password)
			if err != nil || !match {
				web.LoginForm("Invalid username or password").Render(r.Context(), w)
				return
			}

			// Create authentication token
			token, err := tokenStore.CreateNewToken(user.ID, 24*time.Hour, tokens.ScopeAuth)
			if err != nil {
				log.Printf("Error creating token: %v", err)
				web.LoginForm("Authentication error").Render(r.Context(), w)
				return
			}

			// Set auth cookie
			http.SetCookie(w, &http.Cookie{
				Name:     "auth_token",
				Value:    token.PlainText,
				Path:     "/",
				Expires:  token.Expiry,
				HttpOnly: true,
			})

			// Redirect to dashboard
			http.Redirect(w, r, "/dashboard", http.StatusSeeOther)
			return
		}

		// GET request - show login form
		msg := r.URL.Query().Get("msg")
		var errorMsg string

		if msg == "account_created" {
			errorMsg = "Account created successfully. Please log in."
		}

		err := web.LoginForm(errorMsg).Render(r.Context(), w)
		if err != nil {
			log.Printf("Error rendering login form: %v", err)
		}
	}
}



================================================
File: handlers/signup_handler.go
================================================
package handlers

import (
	"log"
	"net/http"
	"time"

	"github.com/strangecousinwst/goworkout/cmd/web"
	"github.com/strangecousinwst/goworkout/internal/store"
	"github.com/strangecousinwst/goworkout/internal/tokens"
)

// SignupWebHandler handles both GET and POST requests for /signup
func SignupWebHandler(userStore store.UserStore, tokenStore store.TokenStore) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method == http.MethodPost {
			err := r.ParseForm()
			if err != nil {
				http.Error(w, "Bad Request", http.StatusInternalServerError)
				return
			}

			username := r.FormValue("username")
			email := r.FormValue("email")
			password := r.FormValue("password")
			bio := r.FormValue("bio")

			// Validate inputs - you can add more validation rules if needed
			if username == "" || email == "" || password == "" {
				web.SignupForm("All fields are required").Render(r.Context(), w)
				return
			}

			// Check if username exists
			existingUser, err := userStore.GetUserByUsername(username)
			if err != nil {
				log.Printf("Error checking username: %v", err)
				web.SignupForm("Error creating account").Render(r.Context(), w)
				return
			}

			if existingUser != nil {
				web.SignupForm("Username already taken").Render(r.Context(), w)
				return
			}

			// Create user
			user := &store.User{
				Username: username,
				Email:    email,
				Bio:      bio,
			}

			// Set password (this handles the hashing)
			err = user.PasswordHash.Set(password)
			if err != nil {
				log.Printf("Error hashing password: %v", err)
				web.SignupForm("Error creating account").Render(r.Context(), w)
				return
			}

			// Insert user into database
			err = userStore.CreateUser(user)
			if err != nil {
				log.Printf("Error creating user: %v", err)
				web.SignupForm("Error creating account").Render(r.Context(), w)
				return
			}

			// Create authentication token
			token, err := tokenStore.CreateNewToken(user.ID, 24*time.Hour, tokens.ScopeAuth)
			if err != nil {
				log.Printf("Error creating token: %v", err)
				// User created but token failed - redirect to login
				http.Redirect(w, r, "/login?msg=account_created", http.StatusSeeOther)
				return
			}

			// Set auth cookie
			http.SetCookie(w, &http.Cookie{
				Name:     "auth_token",
				Value:    token.PlainText,
				Path:     "/",
				Expires:  token.Expiry,
				HttpOnly: true,
			})

			// Redirect to dashboard
			http.Redirect(w, r, "/dashboard", http.StatusSeeOther)
			return
		}

		// GET - show signup form
		err := web.SignupForm("").Render(r.Context(), w)
		if err != nil {
			log.Printf("Error rendering signup form: %v", err)
		}
	}
}



================================================
File: handlers/workout_handlers.go
================================================
package handlers

import (
	"log"
	"net/http"
	"strconv"

	"github.com/go-chi/chi/v5"
	"github.com/strangecousinwst/goworkout/cmd/web"
	"github.com/strangecousinwst/goworkout/internal/middleware"
	"github.com/strangecousinwst/goworkout/internal/store"
)

// WorkoutCreateHandler handles GET/POST for workout creation
func WorkoutCreateHandler(workoutStore store.WorkoutStore) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		user := middleware.GetUser(r)
		if user == nil || user == store.AnonymousUser {
			http.Redirect(w, r, "/login", http.StatusSeeOther)
			return
		}

		if r.Method == http.MethodPost {
			// Process form submission
			err := r.ParseForm()
			if err != nil {
				http.Error(w, "Bad request", http.StatusBadRequest)
				return
			}

			// Extract form values
			title := r.FormValue("title")
			description := r.FormValue("description")
			durationStr := r.FormValue("duration_minutes")
			caloriesStr := r.FormValue("calories_burned")

			// Validate required fields
			if title == "" {
				// Return form with error
				web.WorkoutForm(nil).Render(r.Context(), w)
				return
			}

			// Convert numeric values
			duration, _ := strconv.Atoi(durationStr)
			calories, _ := strconv.Atoi(caloriesStr)

			// Create workout
			workout := &store.Workout{
				UserID:          user.ID,
				Title:           title,
				Description:     description,
				DurationMinutes: duration,
				CaloriesBurned:  calories,
			}

			// Handle exercise entries if needed
			// This would parse the form entries for exercises

			// Save to database
			createdWorkout, err := workoutStore.CreateWorkout(workout)
			if err != nil {
				log.Printf("Error creating workout: %v", err)
				http.Error(w, "Could not create workout", http.StatusInternalServerError)
				return
			}

			// Redirect to the new workout
			http.Redirect(w, r, "/workouts/"+strconv.Itoa(createdWorkout.ID), http.StatusSeeOther)
			return
		}

		// GET request - show form
		err := web.WorkoutForm(nil).Render(r.Context(), w)
		if err != nil {
			log.Printf("Error rendering workout form: %v", err)
		}
	}
}

// WorkoutEditHandler handles viewing/editing of existing workouts
func WorkoutEditHandler(workoutStore store.WorkoutStore) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Get user and ensure authenticated
		user := middleware.GetUser(r)
		if user == nil || user == store.AnonymousUser {
			http.Redirect(w, r, "/login", http.StatusSeeOther)
			return
		}

		// Get workout ID from URL
		idParam := chi.URLParam(r, "id")
		id, err := strconv.Atoi(idParam)
		if err != nil {
			http.Error(w, "Invalid workout ID", http.StatusBadRequest)
			return
		}

		// Fetch workout from database
		workout, err := workoutStore.GetWorkoutByID(id)
		if err != nil {
			http.Error(w, "Workout not found", http.StatusNotFound)
			return
		}

		// Ensure user owns this workout
		if workout.UserID != user.ID {
			http.Error(w, "Not authorized", http.StatusForbidden)
			return
		}

		if r.Method == http.MethodPost {
			// Process form submission for edit
			err := r.ParseForm()
			if err != nil {
				http.Error(w, "Bad request", http.StatusBadRequest)
				return
			}

			// Update workout fields
			workout.Title = r.FormValue("title")
			workout.Description = r.FormValue("description")
			durationStr := r.FormValue("duration_minutes")
			caloriesStr := r.FormValue("calories_burned")

			// Convert numeric values
			workout.DurationMinutes, _ = strconv.Atoi(durationStr)
			workout.CaloriesBurned, _ = strconv.Atoi(caloriesStr)

			// Update in database
			err = workoutStore.UpdateWorkout(workout)
			if err != nil {
				log.Printf("Error updating workout: %v", err)
				http.Error(w, "Could not update workout", http.StatusInternalServerError)
				return
			}

			// Redirect to workout detail
			http.Redirect(w, r, "/workouts/"+idParam, http.StatusSeeOther)
			return
		}

		// GET request - show edit form with workout data
		err = web.WorkoutForm(workout).Render(r.Context(), w)
		if err != nil {
			log.Printf("Error rendering workout form: %v", err)
		}
	}
}

// WorkoutListHandler shows all workouts for the current user
func WorkoutListHandler(workoutStore store.WorkoutStore) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		user := middleware.GetUser(r)
		if user == nil || user == store.AnonymousUser {
			http.Redirect(w, r, "/login", http.StatusSeeOther)
			return
		}

		workouts, err := workoutStore.GetWorkoutsForUser(user.ID)
		if err != nil {
			log.Printf("Error getting workouts: %v", err)
			http.Error(w, "Error loading workouts", http.StatusInternalServerError)
			return
		}

		err = web.WorkoutList(workouts).Render(r.Context(), w)
		if err != nil {
			log.Printf("Error rendering workout list: %v", err)
		}
	}
}

// Add this handler for viewing workout details
func WorkoutDetailHandler(workoutStore store.WorkoutStore) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Get user
		user := middleware.GetUser(r)
		if user == nil || user == store.AnonymousUser {
			http.Redirect(w, r, "/login", http.StatusSeeOther)
			return
		}

		// Get workout ID from URL
		idParam := chi.URLParam(r, "id")
		id, err := strconv.Atoi(idParam)
		if err != nil {
			log.Printf("Invalid workout ID: %v", err)
			http.Error(w, "Invalid workout ID", http.StatusBadRequest)
			return
		}

		// Fetch workout from database
		workout, err := workoutStore.GetWorkoutByID(id)
		if err != nil {
			log.Printf("Error fetching workout: %v", err)
			http.Error(w, "Workout not found", http.StatusNotFound)
			return
		}

		// Ensure user owns this workout
		if workout.UserID != user.ID {
			http.Error(w, "Not authorized", http.StatusForbidden)
			return
		}

		// Render the workout detail template
		err = web.WorkoutDetail(*workout).Render(r.Context(), w)
		if err != nil {
			log.Printf("Error rendering workout detail: %v", err)
		}
	}
}



================================================
File: middleware/middleware.go
================================================
package middleware

import (
	"net/http"
	"strings"

	"github.com/strangecousinwst/goworkout/internal/store"
	"github.com/strangecousinwst/goworkout/internal/tokens"
	"github.com/strangecousinwst/goworkout/internal/utils"
	"golang.org/x/net/context"
)

type UserMiddleware struct {
	UserStore store.UserStore
}

type contextKey string

const UserContextKey = contextKey("user")

func SetUser(r *http.Request, user *store.User) *http.Request {
	ctx := context.WithValue(r.Context(), UserContextKey, user)
	return r.WithContext(ctx)
}

func GetUser(r *http.Request) *store.User {
	user, ok := r.Context().Value(UserContextKey).(*store.User)
	if !ok {
		panic("missing user in request") // bad actor call
	}
	return user
}

func (um *UserMiddleware) Authenticate(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// within this anonymous function
		// we can interject any incoming requests to the server

		w.Header().Add("Vary", "Authorization")
		authHeader := r.Header.Get("Authorization")

		if authHeader == "" {
			cookie, err := r.Cookie("auth_token")
			if err == nil {
				authHeader = "Bearer " + cookie.Value
			}
		}

		if authHeader == "" {
			r = SetUser(r, store.AnonymousUser)
			next.ServeHTTP(w, r)
			return
		}

		headerParts := strings.Split(authHeader, " ")
		if len(headerParts) != 2 || headerParts[0] != "Bearer" {
			r = SetUser(r, store.AnonymousUser)
			next.ServeHTTP(w, r)
			return
		}

		token := headerParts[1]
		user, err := um.UserStore.GetUserToken(tokens.ScopeAuth, token)
		if err != nil {
			utils.WriteJSON(w, http.StatusUnauthorized, utils.Envelope{"error": "invalid token"})
			return
		}

		if user == nil {
			utils.WriteJSON(w, http.StatusUnauthorized, utils.Envelope{"error": "token expired or invalid"})
			return
		}

		r = SetUser(r, user)
		next.ServeHTTP(w, r)
	})
}

func (um *UserMiddleware) RequireUser(next http.HandlerFunc) http.HandlerFunc {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		user := GetUser(r)

		if user.IsAnonymous() {
			utils.WriteJSON(w, http.StatusUnauthorized, utils.Envelope{"error": "you must be logged in to access this route"})
			return
		}

		next.ServeHTTP(w, r)
	})
}



================================================
File: server/routes.go
================================================
package server

import (
	"net/http"

	"github.com/a-h/templ"
	"github.com/go-chi/chi/v5"
	chimiddleware "github.com/go-chi/chi/v5/middleware"
	"github.com/go-chi/cors"
	"github.com/strangecousinwst/goworkout/cmd/web"
	"github.com/strangecousinwst/goworkout/internal/handlers"
)

func (s *Server) RegisterRoutes() http.Handler {
	r := chi.NewRouter()

	// Common middleware stack
	r.Use(chimiddleware.Logger)
	r.Use(chimiddleware.Recoverer)
	r.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"https://*", "http://*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type"},
		AllowCredentials: true,
		MaxAge:           300,
	}))

	// Static assets
	fileServer := http.FileServer(http.FS(web.Files))
	r.Handle("/assets/*", fileServer)

	// Web routes
	s.registerWebRoutes(r)

	// API routes with version
	s.registerAPIRoutes(r)

	r.Get("/login", handlers.LoginWebHandler(s.UserStore, s.TokenStore))
	r.Post("/login", handlers.LoginWebHandler(s.UserStore, s.TokenStore))
	r.Get("/signup", handlers.SignupWebHandler(s.UserStore, s.TokenStore))
	r.Post("/signup", handlers.SignupWebHandler(s.UserStore, s.TokenStore))

	r.Get("/", handlers.HelloWebHandler)
	r.Get("/health", s.healthHandler)
	r.Post("/users", s.UserAPI.HandleRegisterUser)
	r.Post("/tokens/authentication", s.TokenAPI.HandleCreateToken)

	r.Get("/web", templ.Handler(web.HelloForm()).ServeHTTP)
	r.Post("/hello", handlers.HelloWebHandler)

	return r
}

func (s *Server) registerWebRoutes(r chi.Router) {
	r.Group(func(r chi.Router) {
		r.Use(s.Middleware.Authenticate)
		r.Get("/workouts/{id}", s.Middleware.RequireUser(s.WorkoutAPI.HandleGetWorkoutByID))
		r.Post("/workouts", s.Middleware.RequireUser(s.WorkoutAPI.HandleCreateWorkout))
		r.Put("/workouts/{id}", s.Middleware.RequireUser(s.WorkoutAPI.HandleUpdateWorkoutByID))
		r.Delete("/workouts/{id}", s.Middleware.RequireUser(s.WorkoutAPI.HandleDeleteWorkoutByID))
	})
	// HTML routes
	// r.Get("/login", web.LoginWebHandler)
	// r.Post("/login", web.LoginWebHandler)
	// r.Get("/", web.DashboardHandler) // Main dashboard
	// r.Get("/web", templ.Handler(web.HelloForm()).ServeHTTP)
	// r.Post("/hello", web.HelloWebHandler)

	// // Add workout-related web routes
	// r.Get("/workouts", web.WorkoutListHandler)
	// r.Get("/workouts/{id}", web.WorkoutDetailHandler)
	// r.Get("/workouts/create", web.WorkoutCreateHandler)
	// // etc...
	// Group routs and stuff here
}

// could add a version prefix here for example
// this handlers return API responses
func (s *Server) registerAPIRoutes(r chi.Router) {
	r.Group(func(r chi.Router) {
		r.Use(s.Middleware.Authenticate)

		r.Get("/dashboard", s.Middleware.RequireUser(handlers.DashboardHandler(s.WorkoutStore)))

		r.Get("/workouts/create", s.Middleware.RequireUser(handlers.WorkoutCreateHandler(s.WorkoutStore)))
		r.Post("/workouts/create", s.Middleware.RequireUser(handlers.WorkoutCreateHandler(s.WorkoutStore)))
		r.Get("/workouts/{id}/edit", s.Middleware.RequireUser(handlers.WorkoutEditHandler(s.WorkoutStore)))
		r.Post("/workouts/{id}/edit", s.Middleware.RequireUser(handlers.WorkoutEditHandler(s.WorkoutStore)))
		r.Get("/workouts", s.Middleware.RequireUser(handlers.WorkoutListHandler(s.WorkoutStore)))
		r.Get("/workouts/{id}", s.Middleware.RequireUser(handlers.WorkoutDetailHandler(s.WorkoutStore)))
	})

	// API routes with version prefix
	// r.Route("/api/v1", func(r chi.Router) {
	// 	// Auth
	// 	r.Post("/login", s.APIHandler.HandleLogin)
	// 	r.Post("/register", s.UserHandler.HandleRegisterUser)

	// 	// User management
	// 	r.Route("/users", func(r chi.Router) {
	// 		r.Get("/", s.UserHandler.HandleGetUsers)
	// 		r.Post("/", s.UserHandler.HandleCreateUser)
	// 		r.Get("/{id}", s.UserHandler.HandleGetUser)
	// 		// etc...
	// 	})

	// 	// Workout management
	// 	r.Route("/workouts", func(r chi.Router) {
	// 		r.Get("/", s.WorkoutHandler.HandleGetWorkouts)
	// 		r.Post("/", s.WorkoutHandler.HandleCreateWorkout)
	// 		// etc...
	// 	})
	// })
}



================================================
File: server/server.go
================================================
package server

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"
	"time"

	_ "github.com/joho/godotenv/autoload"

	"github.com/strangecousinwst/goworkout/internal/api"
	"github.com/strangecousinwst/goworkout/internal/database"
	"github.com/strangecousinwst/goworkout/internal/middleware"
	"github.com/strangecousinwst/goworkout/internal/store"
	"github.com/strangecousinwst/goworkout/migrations"
)

type Server struct {
	port         int
	Logger       *log.Logger
	WorkoutAPI   *api.WorkoutAPI
	UserAPI      *api.UserAPI
	TokenAPI     *api.TokenAPI
	WorkoutStore *store.PostgresWorkoutStore
	UserStore    *store.PostgresUserStore
	TokenStore   *store.PostgresTokenStore
	Middleware   middleware.UserMiddleware
	db           database.Service
}

func NewServer() *http.Server {
	port, err := strconv.Atoi(os.Getenv("PORT"))
	if err != nil {
		port = 8080
	}

	logger := log.New(os.Stdout, "", log.Ldate|log.Ltime)
	// NewServer := &Server{
	// 	port: port,

	// 	db: database.New(),
	// }
	dbService := database.New()
	pgDB := dbService.GetDB()

	err = database.MigrateFS(pgDB, migrations.FS, ".")
	if err != nil {
		panic(err)
	}

	// TODO: Implement stores
	workoutStore := store.NewPostgresWorkoutStore(pgDB)
	userStore := store.NewPostgresUserStore(pgDB)
	tokenStore := store.NewPostgresTokenStore(pgDB)

	// TODO: Implement handlers
	workoutAPI := api.NewWorkoutAPI(workoutStore, logger)
	userAPI := api.NewUserAPI(userStore, logger)
	tokenAPI := api.NewTokenAPI(tokenStore, userStore, logger)
	middlewareHandler := middleware.UserMiddleware{UserStore: userStore}

	server := &Server{
		port:         port,
		Logger:       logger,
		WorkoutAPI:   workoutAPI,
		UserAPI:      userAPI,
		TokenAPI:     tokenAPI,
		WorkoutStore: workoutStore,
		UserStore:    userStore,
		TokenStore:   tokenStore,
		Middleware:   middlewareHandler,
		db:           dbService,
	}

	// Declare Server config
	httpServer := &http.Server{
		Addr:         fmt.Sprintf(":%d", server.port),
		Handler:      server.RegisterRoutes(),
		IdleTimeout:  time.Minute,
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 30 * time.Second,
	}

	return httpServer
}

func (s *Server) healthHandler(w http.ResponseWriter, r *http.Request) {
	jsonResp, _ := json.Marshal(s.db.Health())
	_, _ = w.Write(jsonResp)
}



================================================
File: store/token_store.go
================================================
package store

import (
	"database/sql"
	"time"

	"github.com/strangecousinwst/goworkout/internal/tokens"
)

type PostgresTokenStore struct {
	db *sql.DB
}

func NewPostgresTokenStore(db *sql.DB) *PostgresTokenStore {
	return &PostgresTokenStore{
		db: db,
	}
}

type TokenStore interface {
	Insert(token *tokens.Token) error
	CreateNewToken(userID int, ttl time.Duration, scope string) (*tokens.Token, error)
	DeleteAllTokensForUser(userID int, scope string) error
}

func (t *PostgresTokenStore) CreateNewToken(userID int, ttl time.Duration, scope string) (*tokens.Token, error) {
	token, err := tokens.GenerateToken(userID, ttl, scope)
	if err != nil {
		return nil, err
	}

	err = t.Insert(token)
	return token, nil
}

func (t *PostgresTokenStore) Insert(token *tokens.Token) error {
	query := `
	INSERT INTO tokens (hash, user_id, expiry, scope)
	VALUES ($1, $2, $3, $4)
	`

	_, err := t.db.Exec(query, token.Hash, token.UserID, token.Expiry, token.Scope)
	return err
}

func (t *PostgresTokenStore) DeleteAllTokensForUser(userID int, scope string) error {
	query := `
	DELETE FROM tokens
	WHERE scope = $1 AND user_id = $2
	`

	_, err := t.db.Exec(query, scope, userID)
	return err
}



================================================
File: store/user_store.go
================================================
package store

import (
	"crypto/sha256"
	"database/sql"
	"errors"
	"time"

	"golang.org/x/crypto/bcrypt"
)

// A password to be set into hash, or matched with a hash
type password struct {
	plainText *string
	hash      []byte
}

// Set plain text password to hash password
func (p *password) Set(plainTextPassword string) error {
	hash, err := bcrypt.GenerateFromPassword([]byte(plainTextPassword), 12)
	if err != nil {
		return err
	}

	p.plainText = &plainTextPassword
	p.hash = hash
	return nil
}

// See if plain text password matches to hash password
func (p *password) Matches(plainTextPassword string) (bool, error) {
	err := bcrypt.CompareHashAndPassword(p.hash, []byte(plainTextPassword))
	if err != nil {
		switch {
		case errors.Is(err, bcrypt.ErrMismatchedHashAndPassword):
			return false, nil
		default:
			return false, err
		}
	}

	return true, nil
}

// User struct, to pass users arround app
type User struct {
	ID           int       `json:"id"`
	Username     string    `json:"username"`
	Email        string    `json:"email"`
	PasswordHash password  `json:"-"`
	Bio          string    `json:"bio"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
}

var AnonymousUser = &User{}

func (u *User) IsAnonymous() bool {
	return u == AnonymousUser
}

type PostgresUserStore struct {
	db *sql.DB
}

func NewPostgresUserStore(db *sql.DB) *PostgresUserStore {
	return &PostgresUserStore{
		db: db,
	}
}

// interface to do db operations
type UserStore interface {
	CreateUser(*User) error
	GetUserByUsername(username string) (*User, error)
	UpdateUser(*User) error
	GetUserToken(scope, tokenPlainText string) (*User, error)
}

func (s *PostgresUserStore) CreateUser(user *User) error {
	query := `
	INSERT INTO users (username, email, password_hash, bio)
	VALUES ($1, $2, $3, $4)
	RETURNING id, created_at, updated_at
	`

	err := s.db.QueryRow(
		query,
		user.Username,
		user.Email,
		user.PasswordHash.hash,
		user.Bio,
	).Scan(
		&user.ID,
		&user.CreatedAt,
		&user.UpdatedAt,
	)
	if err != nil {
		return err
	}

	return nil
}

func (s *PostgresUserStore) GetUserByUsername(username string) (*User, error) {
	user := &User{
		PasswordHash: password{},
	}

	query := `
	SELECT id, username, email, password_hash, bio, created_at, updated_at
	FROM users
	WHERE username = $1
	`

	err := s.db.QueryRow(
		query,
		username,
	).Scan(
		&user.ID,
		&user.Username,
		&user.Email,
		&user.PasswordHash.hash,
		&user.Bio,
		&user.CreatedAt,
		&user.UpdatedAt,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	return user, nil
}

func (s *PostgresUserStore) UpdateUser(user *User) error {
	query := `
	UPDATE users
	SET username = $1, email = $2, bio = $3, updated_at = CURRENT_TIMESTAMP
	WHERE id = $4
	RETURNING updated_at
	`

	result, err := s.db.Exec(
		query,
		user.Username,
		user.Email,
		user.Bio,
		user.ID,
	)
	if err != nil {
		return err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if rowsAffected == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (s *PostgresUserStore) GetUserToken(scope, plainTextPassword string) (*User, error) {
	tokenHash := sha256.Sum256([]byte(plainTextPassword))

	query := `
	SELECT u.id, u.username, u.email, u.password_hash, u.bio, u.created_at, u.updated_at
	FROM users u
	INNER JOIN tokens t ON t.user_id = u.id
	WHERE t.hash = $1 AND t.scope = $2 AND t.expiry > $3
	`

	user := &User{
		PasswordHash: password{},
	}

	err := s.db.QueryRow(
		query,
		tokenHash[:],
		scope,
		time.Now(),
	).Scan(
		&user.ID,
		&user.Username,
		&user.Email,
		&user.PasswordHash.hash,
		&user.Bio,
		&user.CreatedAt,
		&user.UpdatedAt,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}

	if err != nil {
		return nil, err
	}

	return user, nil
}



================================================
File: store/workout_store.go
================================================
package store

import "database/sql"

type Workout struct {
	ID              int            `json:"id"`
	UserID          int            `json:"user_id"`
	Title           string         `json:"title"`
	Description     string         `json:"description"`
	DurationMinutes int            `json:"duration_minutes"`
	CaloriesBurned  int            `json:"calorties_burned"`
	Entries         []WorkoutEntry `json:"entries"`
}

type WorkoutEntry struct {
	ID              int      `json:"id"`
	ExerciseName    string   `json:"exercise_name"`
	Sets            int      `json:"sets"`
	Reps            *int     `json:"reps"`
	DurationSeconds *int     `json:"duration_seconds"`
	Weight          *float64 `json:"weight"`
	Notes           string   `json:"notes"`
	OrderIndex      int      `json:"order_index"`
}

type PostgresWorkoutStore struct {
	db *sql.DB
}

func NewPostgresWorkoutStore(db *sql.DB) *PostgresWorkoutStore {
	return &PostgresWorkoutStore{
		db: db,
	}
}

type WorkoutStore interface {
	CreateWorkout(*Workout) (*Workout, error)
	GetWorkoutByID(id int) (*Workout, error)
	UpdateWorkout(*Workout) error
	DeleteWorkout(id int) error
	GetWorkoutOwner(id int) (int, error)
	GetWorkoutsForUser(id int) ([]Workout, error)
}

func (s *PostgresWorkoutStore) CreateWorkout(workout *Workout) (*Workout, error) {
	tx, err := s.db.Begin()
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	query := `
	INSERT INTO workouts (user_id, title, description, duration_minutes, calories_burned)
	VALUES ($1, $2, $3, $4, $5)
	RETURNING ID
	`

	err = tx.QueryRow(
		query,
		workout.ID,
		workout.Title,
		workout.Description,
		workout.DurationMinutes,
		workout.CaloriesBurned,
	).Scan(
		&workout.ID,
	)

	for i := range workout.Entries {
		entry := &workout.Entries[i]

		query = `
		INSERT INTO workout_entries (workout_id, exercise_name, sets, reps, duration_seconds, weight, notes, order_index)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
		RETURNING id
		`

		err = tx.QueryRow(
			query,
			workout.ID,
			entry.ExerciseName,
			entry.Sets,
			entry.Reps,
			entry.DurationSeconds,
			entry.Weight,
			entry.Notes,
			entry.OrderIndex,
		).Scan(
			&entry.ID,
		)
		if err != nil {
			return nil, err
		}
	}

	err = tx.Commit()
	if err != nil {
		return nil, err
	}

	return workout, nil
}

func (pg *PostgresWorkoutStore) GetWorkoutByID(id int) (*Workout, error) {
	workout := &Workout{}
	query := `
	SELECT id, title, description, duration_minutes, calories_burned
	FROM workouts
	WHERE id = $1
	`

	err := pg.db.QueryRow(query, id).Scan(&workout.ID, &workout.Title, &workout.Description, &workout.DurationMinutes, &workout.CaloriesBurned)
	if err == sql.ErrNoRows {
		return nil, nil
	}

	if err != nil {
		return nil, err
	}

	// get the entries
	entryQuery := `
	SELECT id, exercise_name, sets, reps, duration_seconds, weight, notes, order_index
	FROM workout_entries
	WHERE workout_id = $1
	ORDER BY order_index
	`

	rows, err := pg.db.Query(entryQuery, workout.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var entry WorkoutEntry
		err := rows.Scan(
			&entry.ID,
			&entry.ExerciseName,
			&entry.Sets,
			&entry.Reps,
			&entry.DurationSeconds,
			&entry.Weight,
			&entry.Notes,
			&entry.OrderIndex,
		)
		if err != nil {
			return nil, err
		}
		workout.Entries = append(workout.Entries, entry)
	}

	return workout, nil
}

func (pg *PostgresWorkoutStore) UpdateWorkout(workout *Workout) error {
	tx, err := pg.db.Begin()
	if err != nil {
		return err
	}
	defer tx.Rollback()

	query := `
	UPDATE workouts
	SET title = $1, description = $2, duration_minutes = $3, calories_burned = $4
	WHERE id = $5
	`

	result, err := tx.Exec(query, workout.Title, workout.Description, workout.DurationMinutes, workout.CaloriesBurned, workout.ID)
	if err != nil {
		return err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return err
	}

	if rowsAffected == 0 {
		return sql.ErrNoRows
	}

	_, err = tx.Exec("DELETE FROM workout_entries WHERE workout_id = $1", workout.ID)
	if err != nil {
		return err
	}

	for _, entry := range workout.Entries {
		query = `
		INSERT INTO workout_entries (workout_id, exercise_name, sets, reps, duration_seconds, weight, notes, order_index)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
		`

		_, err = tx.Exec(query,
			workout.ID,
			entry.ExerciseName,
			entry.Sets,
			entry.Reps,
			entry.DurationSeconds,
			entry.Weight,
			entry.Notes,
			entry.OrderIndex,
		)
		if err != nil {
			return err
		}
	}

	return tx.Commit()
}

func (pg *PostgresWorkoutStore) DeleteWorkout(id int) error {
	query := `
	DELETE FROM workouts
	WHERE id = $1
	`

	result, err := pg.db.Exec(query, id)
	if err != nil {
		return err
	}
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return err
	}

	if rowsAffected == 0 {
		return sql.ErrNoRows
	}

	return nil
}

func (pg *PostgresWorkoutStore) GetWorkoutOwner(workoutID int) (int, error) {
	var userID int

	query := `
	SELECT user_id
	FROM workouts
	WHERE id = $1
	`

	err := pg.db.QueryRow(query, workoutID).Scan(&userID)
	if err != nil {
		return 0, err
	}

	return userID, nil
}

func (pg *PostgresWorkoutStore) GetWorkoutsForUser(userID int) ([]Workout, error) {
	query := `
    SELECT id, user_id, title, description, duration_minutes, calories_burned, created_at, updated_at 
    FROM workouts
    WHERE user_id = $1
    ORDER BY created_at DESC
    `

	rows, err := pg.db.Query(query, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var workouts []Workout
	for rows.Next() {
		var w Workout
		err := rows.Scan(
			&w.ID,
			&w.UserID,
			&w.Title,
			&w.Description,
			&w.DurationMinutes,
			&w.CaloriesBurned,
		)
		if err != nil {
			return nil, err
		}
		workouts = append(workouts, w)
	}

	return workouts, nil
}



================================================
File: tokens/tokens.go
================================================
package tokens

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/base32"
	"time"
)

const (
	ScopeAuth = "authentication"
)

type Token struct {
	PlainText string    `json:"token"`
	Hash      []byte    `json:"-"`
	UserID    int       `json:"-"`
	Expiry    time.Time `json:"expiry"`
	Scope     string    `json:"-"`
}

func GenerateToken(userID int, ttl time.Duration, scope string) (*Token, error) {
	// Generate a new token with the given user ID, TTL, and scope
	// This is a placeholder implementation. In a real application,
	// you would use a secure random generator to create the token.
	token := &Token{
		UserID: userID,
		Expiry: time.Now().Add(ttl),
		Scope:  scope,
	}

	emptyBytes := make([]byte, 32)
	_, err := rand.Read(emptyBytes)
	if err != nil {
		return nil, err
	}

	token.PlainText = base32.StdEncoding.WithPadding(base32.NoPadding).EncodeToString(emptyBytes)
	hash := sha256.Sum256([]byte(token.PlainText))
	token.Hash = hash[:]

	return token, nil
}



================================================
File: utils/utils.go
================================================
package utils

import (
	"encoding/json"
	"errors"
	"net/http"
	"strconv"

	"github.com/go-chi/chi/v5"
)

type Envelope map[string]interface{}

func WriteJSON(w http.ResponseWriter, status int, data Envelope) error {
	js, err := json.MarshalIndent(data, "", " ")
	if err != nil {
		return err
	}

	js = append(js, '\n')
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	w.Write(js)

	return nil
}

func ReadIDParam(r *http.Request) (int, error) {
	idParam := chi.URLParam(r, "id")
	if idParam == "" {
		return 0, errors.New("invalid id parameter")
	}

	id, err := strconv.Atoi(idParam)
	if err != nil {
		return 0, errors.New("invalid id parameter type")
	}

	return id, nil
}


